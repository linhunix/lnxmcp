<?php
////////////////////////////////////////////////////////////////////////////////
// ERROR/CONFIG
////////////////////////////////////////////////////////////////////////////////
/**
 * Exit with closure procedure
 *
 * @param  mixed $message
 *
 * @return void
 */
function LnxMcpExit($message = "")
{
    lnxmcp()->info("DumpAndExit:" . $message);
    lnxmcp()->runTag("Exit");
    exit();
}
if (function_exists("DumpAndExit") != true) {
    /**
     * DumpAndExit
     *
     * @param  mixed $message
     *
     * @return void
     */
    function DumpAndExit($message = "")
    {
        lnxmcp()->info("DumpAndExit:" . $message);
        lnxmcp()->runTag("Exit");
        foreach (debug_backtrace() as $row => $debug) {
            if (is_array($debug)) {
                foreach ($debug as $drow => $ddebug) {
                    lnxmcp()->debug("[" . $drow . "]>>" . print_r($ddebug, 1));
                }
            }
        }
        exit();
    }
    /**
     * this version has only the error log call because is work when is present a big issue
     * @param String $message
     * @param bool $exit
     */
    function DumpOnFatal($message, $exit = false)
    {
        lnxmcp()->runTag("Fatal");
        lnxmcp()->runTag("Exit");
        echo $message;
        foreach (debug_backtrace() as $errarr) {
            error_log("-> " . $errarr["file"] . " : " . $errarr["line"] . " <br>");
        }
        foreach (get_included_files() as $filename) {
            error_log("Load: $filename");
        }
        error_log("FATAL ERROR - lnxmcp is NOT SETTED!!! ");
        error_log(debug_print_backtrace());
        if ($exit == true) {
            exit(1);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// AUTOLOAD/CONFIG
////////////////////////////////////////////////////////////////////////////////
/**
 * A basic autoload implementation that should be compatible with PHP 5.2.
 *
 * @author pmg
 */
function legacyAutoload($className)
{
    global $autoLoadFolders;
    $className = str_replace('/LinHUniX/', '/', $className);
    foreach ($autoLoadFolders as $folder) {
        $classPath = $folder . DIRECTORY_SEPARATOR . $className . '.php';
        if (file_exists($classPath)) {
            require_once $classPath;
            return true;
        }
    }
    return false;
}

/**
 * A basic autoload implementation that should be compatible with PHP 5.2.
 *
 * @author pmg
 */
function selfAutoLoad($srcPath)
{
    global $autoLoadFolders;
    $srcPath = realpath($srcPath);
    $scannedItems = scandir($srcPath);
    foreach ($scannedItems as $item) {
        if ($item === '.' || $item === '..') {
            continue;
        }
        if (is_dir($folder = $srcPath . DIRECTORY_SEPARATOR . $item)) {
            $autoLoadFolders[] = $folder;
        }
    }
    spl_autoload_register('legacyAutoload', true/*, true*/ );
}

/**
 * linhunix json array converter
 *
 * @param  mixed $file
 * @param  mixed $path if is need
 * @param  mixed $ext with out the '.'
 *
 * @return any json object converted as array
 */
function lnxGetJsonFile($file, $path = "", $ext = "")
{
    $jfile = $path;
    if ($jfile != "") {
        $jfile .= DIRECTORY_SEPARATOR . $file;
    }
    if ($ext != "") {
        $jfile .= "." . $ext;
    }
    if (file_exists($jfile)) {
        try {
            lnxmcp()->info("lnxGetJsonFile:" . $jfile);
            return json_decode(file_get_contents($jfile), true);
        } catch (\Exception $e) {
            lnxmcp()->warning("lnxGetJsonFile>>file:" . $jfile . " and err:" . $e->get_message());
            return false;
        }
    } else {
        lnxmcp()->info("lnxGetJsonFile>>file:" . $jfile . " and not found");
    }
    return null;
}
/**
 * linhunix json array converter
 *
 * @param  mixed $content
 * @param  mixed $file
 * @param  mixed $path if is need
 * @param  mixed $ext with out the '.'
 *
 * @return bool
 */
function lnxPutJsonFile($content,$file, $path = "", $ext = "")
{
    $jfile = $path;
    if ($jfile != "") {
        $jfile .= DIRECTORY_SEPARATOR . $file;
    }
    if ($ext != "") {
        $jfile .= "." . $ext;
    }
    if (! is_dir(dirname($jfile))) {
        lnxmcp()->warning("lnxPutJsonFile:" . dirname($jfile). " not exist!!");
        return false;
    }
    if (! is_writable(dirname($jfile))) {
        lnxmcp()->warning("lnxPutJsonFile:" . dirname($jfile). " not writable!!");
        return false;
    }
    try {
        lnxmcp()->info("lnxPutJsonFile:" . $jfile);
        return file_put_contents($jfile, json_encode($content,JSON_PRETTY_PRINT));
    } catch (\Exception $e) {
        lnxmcp()->warning("lnxPutJsonFile>>file:" . $jfile . " and err:" . $e->get_message());
        return false;
    }
    return null;
}

/**
 * lnxmcp
 *
 * @return mastercontrolprogram
 */
function lnxmcp()
{
    if (isset($GLOBALS["mcp"])) {
        return $GLOBALS["mcp"];
    } else {
        DumpOnFatal("FATAL ERROR - lnxmcp is NOT SETTED!!! \n", true);
    }
}

/**
 * LinHUnix Master Control Program 
 * Fast Tag caller 
 *
 * @param  mixed $tagname
 * @param  mixed $scopein
 *
 * @return void
 */
function lnxMcpTag($tagname, array $scopeIn = array())
{
    lnxmcp()->runTag($tagname, $scopeIn);
}
/**
 * linhunixErrorHandlerDev
 *
 * @param  mixed $errno
 * @param  mixed $errstr
 * @param  mixed $errfile
 * @param  mixed $errline
 *
 * @return void
 */
function linhunixErrorHandlerDev($errno, $errstr, $errfile, $errline)
{
    if (!(error_reporting() & $errno)) {
        return false;
    }
    $errtype = $errno;
    $exit = false;
    $drvlvl = 0;
    switch ($errno) {
        case E_ERROR:
            lnxmcp()->error($errstr . "[" . $errfile . "] [" . $errline . "]");
            lnxmcp()->supportmail($errstr);
            $exit = true;
            break;
        case E_PARSE:
        case E_CORE_ERROR:
        case E_COMPILE_ERROR :
        case E_RECOVERABLE_ERROR:
        case E_USER_ERROR:
            lnxmcp()->error($errstr . "[" . $errfile . "] [" . $errline . "]");
            lnxmcp()->supportmail($errstr);
            break;
        case E_USER_DEPRECATED:
        case E_WARNING:
        case E_USER_WARNING:
            lnxmcp()->warning($errstr . "[" . $errfile . "] [" . $errline . "]");
            break;
        case E_NOTICE:
        case E_USER_NOTICE:
            $errtype = "INF";
            lnxmcp()->info($errstr . "[" . $errfile . "] [" . $errline . "]");
            break;
        default:
            $errtype = "DBG";
            lnxmcp()->debug($errstr . "[" . $errfile . "] [" . $errline . "]");
            break;
    }
    if ($exit) {
        \header("HTTP/1.1 302 Moved Temporarily", true, 302);
        \header('Location: /500', true, 500);
        exit(1);
        exit(1);
    }
    return true;
}

/**
 * mcpErrorHandlerInit
 *
 * @return void
 */
function mcpErrorHandlerInit()
{
    $old_error_handler = set_error_handler("linhunixErrorHandlerDev");
}

/**
 * Run Module as Check sequence
 * @param string $cfgvalue name of the Doctrine
 * @param string $modinit  Module name where is present the code and be load and initalized
 * @param string $path     path where present the basedirectory of the data
 * @param array $scopeIn   Input Array with the value need to work
 * @param string $subcall  used if the name of the functionality ($callname) and the subcall are different
 * @return array $ScopeOut
 */
function lnxmcpChk($checkmenu=null)
{
    $mcpCheckFile = lnxmcp()->getCfg("mcp.path") . "/../mcp_modules/Chk/Shell/mcpCheck.php";
    lnxmcp()->info("Try to load CheckModule:".$mcpCheckFile);
    if (file_exists($mcpCheckFile)) {
        echo "load Check Env on $mcpCheckFile..\n";
        include_once($mcpCheckFile);
        echo "Run mcpCheck:\n";
        LinHUniX\McpModules\Chk\Shell\mcpCheck($checkmenu);
        echo "Check Complete!!\n";
    }
}
/**
 * Run Module as Check sequence
 * @param string $cfgvalue name of the Doctrine
 * @param string $modinit  Module name where is present the code and be load and initalized
 * @param string $path     path where present the basedirectory of the data
 * @param array $scopeIn   Input Array with the value need to work
 * @param string $subcall  used if the name of the functionality ($callname) and the subcall are different
 * @return array $ScopeOut
 */
function lnxmcpDbM($command=null,$element=null)
{
    if (empty($command)){
        $command= "help";
    }
    if (empty($element)){
        $element= null;
    }
    $mcpCheckFile = lnxmcp()->getCfg("mcp.path") . "/../mcp_modules/DbMig/Shell/mcpDbMigrate.php";
    lnxmcp()->info("Try to load DbMigrateModule:".$mcpCheckFile);
    if (file_exists($mcpCheckFile)) {
        echo "load DbMigrate Env on $mcpCheckFile..\n";
        include_once($mcpCheckFile);
        echo "Run DbMigrate:$command\n";
        new LinHUniX\McpModules\DbMig\Shell\mcpDbMigrate($command,$element);
        echo "DbMigrate Complete!!\n";
    }
}
/**
 * linhunix json array converter
 *
 * @param  mixed $content
 * @param  mixed $file
 * @param  mixed $path if is need
 * @param  mixed $ext with out the '.'
 *
 * @return bool
 */
function lnxHtmlPage($file, $path = "", $ext = "html",$scopeIn=array())
{
    $hfile = realpath($path);
    if ($hfile == "") {
        $hfile = $path;
    }
    if ($hfile != "") {
        $hfile .= DIRECTORY_SEPARATOR . $file;
    }
    if ($ext != "") {
        $hfile .= "." . $ext;
    }
    if (!file_exists($hfile)) {
        $app_path=lnxmcp()->getResource("path");
        $hfile=$app_path.DIRECTORY_SEPARATOR.$hfile;
    }
    if (file_exists($hfile)) {
        try {
            lnxmcp()->info("lnxHtmlPage:" . $hfile);
            return lnxmcp()->converTag(file_get_contents($hfile),$scopeIn);
        } catch (\Exception $e) {
            lnxmcp()->warning("lnxHtmlPage>>file:" . $hfile . " and err:" . $e->getMessage());
            return false;
        }
    } else {
        lnxmcp()->info("lnxHtmlPage>>file:" . $hfile . " and not found");
    }
    return null;
}
